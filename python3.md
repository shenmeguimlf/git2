**tuple**
不可变的有序序列 要想表示包含1的单元素元组，我们应该写成(1,)

a, b, c = 'xyz'会将a绑定到x、b绑定到y、c绑定到z

**range** python2中不存在的类型 范围也是不可变的。range函数会返回一个range类型的对象 

range函数接受3个整数参数：start、stop和step，并返回整数数列start、start +
step、start + 2 * step、等等。如果step是个正数，那么最后一个元素就是小于stop的最大
整数start + i * step。如果step是个负数，那么最后一个元素就是大于stop的最小整数start +
i * step。如果只有2个实参，那么步长就为1。如果只有1个实参，那么这个参数就是结束值，
起始值默认为0，步长默认为1。

使用==操作符比较两个range类型的对象时，如果两个范围表示同
样的整数序列，那么就返回True。例如，range(0, 7, 2) == range(0, 8, 2)的值就是True，
但range(0, 7, 2) == range(6, -1, -2)的值则是False。因为尽管这两个范围包含同样的整
数，但顺序是不一样的。

**list**
单元素列表不需要在闭括号前面加上那个（特别容易忘掉的）逗号。

**操作符+确实没有副作用，它会创建并返回一个新的列表。相反，extend和append
都会改变L1。**

>L.remove(e)：从L中删除第一个出现的e。
>L.pop(i)：删除并返回L中索引值为i的项目。如果L为空，则抛出一个异常。
如果i被省略，则i的默认值为-1，删除并返回L中的最后一个元素。

**我们通常应该尽量避免修改一个正在进行遍历的列表。**
避免这种问题的方法是使用切片操作克隆①（即复制）这个列表，并使用for e1 in L1[:]
这种写法。请注意下面这种写法：
newL1 = L1
for e1 in newL1:
不能解决问题。这样不能复制L1，只能为现有列表引入一个新的名称。
在Python中，切片不是克隆列表的唯一方法。表达式list(L)会返回列表L的一份副本。如果
待复制的列表包含可变对象，而且你也想复制这些可变对象，那么可以导入标准库模块copy，然
后使用函数copy.deepcopy。

在Python中，函数是一等对象。这意味着我们可以像对待其他类型的对象（如int或list）
一样对待函数。使用函数作为实参可以实现一种名为高阶编程的编码方式.

Python中有一个内置的高阶函数***map***

***lambda <sequence of variable names>: <expression>***
举例来说，Lambda表达式lambda x, y: x*y会返回一个函数，这个函数的返回值为两个参
数的乘积。Lambda表达式经常用作高阶函数的实参
```python
L = []
for i in map(lambda x, y: x**y, [1 ,2 ,3, 4], [3, 2, 1, 0]):
    L.append(i)
print(L)
```

会输出[1, 4, 3, 1]。
**string** s.rfind(s1)：功能与find相同，只是从s的末尾开始反向搜索（rfind中的r表示反向）。
